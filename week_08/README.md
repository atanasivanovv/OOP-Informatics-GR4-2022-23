# Упражнение 6

## Какво правихме предния път?

- голяма четворка
- имлпементация на голяма четворка
- какво са header файловете

## static fields

Можем да дефинираме статични членове на класа с помощта на ключова дума static. Когато декларираме член-данна на клас като статична, това означава, че независимо колко обекта на класа са създадени, има само едно копие на статичната член-данна.

```c++
class A {
private:
    static int field;
};
```

Статичната член-данна **се споделя от всички обекти на класа**. Всички статични данни се инициализират на нула при създаването на първия обект, ако не е налице друга инициализация. Не можем да го поставим в дефиницията на класа, но може да бъде инициализиран извън класа, както е направено в следващия пример чрез повторно деклариране на статичната променлива, като се използва операторът `::`, за да се идентифицира към кой клас принадлежи.

```c++
int main() {
    std::cout << A::field << std::endl;
}
```

## static methods

Като декларираме функция като статична, ние я правим **независима от всеки един обект от този клас**. Статична функция-член може да бъде извикана, дори ако не съществуват обекти от класа и това се осъществява чрез използването отново на синтаксиса <име на клас>::<име на метод>

```c++
class A {
public:
    static void printField();
};

int main() {
    A::printField();
}
```

Статичната функция може да осъществява достъп **само до статичните член-данни**, други статични функции и всякакви други функции извън класа.

Статичните функции-членове имат обхват на класа и те нямат достъп до указателя this на класа. Можете да използвате функция за статичен член, за да определите дали някои обекти от класа са създадени или не например.

Въпрос: Защо не можем да достъпваме НЕ-СТАТИЧНИ член данни в СТАТИЧНИ методи?

## Exceptions (изключения)

При изпълнение на C++ код могат да възникнат различни грешки: грешки в синтактиса на кода, направени от програмиста, грешки поради неправилно въвеждане или други непредвидими неща.

Когато възникне грешка, C++ обикновено спира и генерира съобщение за грешка. Техническият термин за това е: C++ ще изведе изключение (изведе грешка). На английски ще го срещнете по-точно като `throw an exception (throw an error)`

### try and catch

Синтаксиса за справяне с грешки обикновенно се състои от ключовите думи: `try`, `throw`, `catch`:

- Операторът try ви позволява да дефинирате блок от код, който да бъде тестван за грешки, докато се изпълнява.

- Ключовата дума throw хвърля изключение, когато бъде открит проблем, което ни позволява да създадем персонализирана грешка.

- Операторът catch ви позволява да дефинирате блок код, който да бъде изпълнен, ако възникне грешка в блока try.

- Ключовите думи try and catch идват по двойки:

```c++
try {
  // Block of code to try
  throw exception; // Throw an exception when a problem arise
}
catch () {
  // Block of code to handle errors
}
```

Пример:

```c++
try {
  int age = 15;
  if (age >= 18) {
    cout << "Access granted - you are old enough.";
  } else {
    throw (age);
  }
}
catch (int myNum) {
  cout << "Access denied - You must be at least 18 years old.\n";
  cout << "Age is: " << myNum;
}
```

Обяснение:

Използваме блока `try`, за да тестваме някакъв код: Ако променливата възраст е по-малка от 18, ние ще хвърлим изключение и ще го обработваме в нашия блок `catch`.

В блока `catch` ние хващаме грешката и правим нещо по въпроса. Инструкцията `catch` приема параметър: в нашия пример използваме променлива int (myNum) (защото хвърляме изключение от тип int в блока `try` (age)), за да изведем стойността на age.

Ако не се появи грешка (например, ако възрастта е 20 вместо 15, което означава, че ще бъде по-голяма от 18), блокът за хващане се пропуска

## Предефиниране на (още) оператори

Разгледахме по-подробно един от най-съществените оператори, които можете да предефинирате, а именно равното (`=`). Нека разгледаме още такива, които биха ви били полезни

- за сравняване:
  - двойно равно (`==`)
  - различно (`!=`)
  - достъп до елемент на индекс (`[]`)
  - оператори за извеждане (`>>` & `<<`) ?
